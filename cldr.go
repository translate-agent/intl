package intl

// Code generated by "earthly +generate". DO NOT EDIT.

import (
	"strconv"
	"strings"
	"time"

	ptime "github.com/yaa110/go-persian-calendar"
	"golang.org/x/text/language"
)

type numberingSystem int

const (
	numberingSystemLatn numberingSystem = iota
	numberingSystemAdlm
	numberingSystemArab
	numberingSystemArabext
	numberingSystemBeng
	numberingSystemCakm
	numberingSystemDeva
	numberingSystemHmnp
	numberingSystemMtei
	numberingSystemMymr
	numberingSystemNkoo
	numberingSystemOlck
	numberingSystemTibt
	numberingSystemLast
)

var numberingSystems = []digits{
	numberingSystemAdlm:    {'𞥐', '𞥑', '𞥒', '𞥓', '𞥔', '𞥕', '𞥖', '𞥗', '𞥘', '𞥙'},
	numberingSystemArab:    {'٠', '١', '٢', '٣', '٤', '٥', '٦', '٧', '٨', '٩'},
	numberingSystemArabext: {'۰', '۱', '۲', '۳', '۴', '۵', '۶', '۷', '۸', '۹'},
	numberingSystemBeng:    {'০', '১', '২', '৩', '৪', '৫', '৬', '৭', '৮', '৯'},
	numberingSystemCakm:    {'𑄶', '𑄷', '𑄸', '𑄹', '𑄺', '𑄻', '𑄼', '𑄽', '𑄾', '𑄿'},
	numberingSystemDeva:    {'०', '१', '२', '३', '४', '५', '६', '७', '८', '९'},
	numberingSystemHmnp:    {'𞅀', '𞅁', '𞅂', '𞅃', '𞅄', '𞅅', '𞅆', '𞅇', '𞅈', '𞅉'},
	numberingSystemMtei:    {'꯰', '꯱', '꯲', '꯳', '꯴', '꯵', '꯶', '꯷', '꯸', '꯹'},
	numberingSystemMymr:    {'၀', '၁', '၂', '၃', '၄', '၅', '၆', '၇', '၈', '၉'},
	numberingSystemNkoo:    {'߀', '߁', '߂', '߃', '߄', '߅', '߆', '߇', '߈', '߉'},
	numberingSystemOlck:    {'᱐', '᱑', '᱒', '᱓', '᱔', '᱕', '᱖', '᱗', '᱘', '᱙'},
	numberingSystemTibt:    {'༠', '༡', '༢', '༣', '༤', '༥', '༦', '༧', '༨', '༩'},
}

func defaultNumberingSystem(locale language.Tag) numberingSystem {
	s := locale.String()

	switch {
	default:
		return numberingSystemLatn
	case s == "ff-Adlm", strings.HasPrefix(s, "ff-Adlm-"):
		return numberingSystemAdlm
	case s == "ar", strings.HasPrefix(s, "ar-"),
		s == "ar-BH", strings.HasPrefix(s, "ar-BH-"),
		s == "ar-DJ", strings.HasPrefix(s, "ar-DJ-"),
		s == "ar-EG", strings.HasPrefix(s, "ar-EG-"),
		s == "ar-ER", strings.HasPrefix(s, "ar-ER-"),
		s == "ar-IL", strings.HasPrefix(s, "ar-IL-"),
		s == "ar-IQ", strings.HasPrefix(s, "ar-IQ-"),
		s == "ar-JO", strings.HasPrefix(s, "ar-JO-"),
		s == "ar-KM", strings.HasPrefix(s, "ar-KM-"),
		s == "ar-KW", strings.HasPrefix(s, "ar-KW-"),
		s == "ar-LB", strings.HasPrefix(s, "ar-LB-"),
		s == "ar-MR", strings.HasPrefix(s, "ar-MR-"),
		s == "ar-OM", strings.HasPrefix(s, "ar-OM-"),
		s == "ar-PS", strings.HasPrefix(s, "ar-PS-"),
		s == "ar-QA", strings.HasPrefix(s, "ar-QA-"),
		s == "ar-SA", strings.HasPrefix(s, "ar-SA-"),
		s == "ar-SD", strings.HasPrefix(s, "ar-SD-"),
		s == "ar-SO", strings.HasPrefix(s, "ar-SO-"),
		s == "ar-SS", strings.HasPrefix(s, "ar-SS-"),
		s == "ar-SY", strings.HasPrefix(s, "ar-SY-"),
		s == "ar-TD", strings.HasPrefix(s, "ar-TD-"),
		s == "ar-YE", strings.HasPrefix(s, "ar-YE-"),
		s == "ckb", strings.HasPrefix(s, "ckb-"),
		s == "sd", strings.HasPrefix(s, "sd-"),
		s == "sdh", strings.HasPrefix(s, "sdh-"):
		return numberingSystemArab
	case s == "az-Arab", strings.HasPrefix(s, "az-Arab-"),
		s == "bgn", strings.HasPrefix(s, "bgn-"),
		s == "fa", strings.HasPrefix(s, "fa-"),
		s == "ks", strings.HasPrefix(s, "ks-"),
		s == "lrc", strings.HasPrefix(s, "lrc-"),
		s == "mzn", strings.HasPrefix(s, "mzn-"),
		s == "pa-Arab", strings.HasPrefix(s, "pa-Arab-"),
		s == "ps", strings.HasPrefix(s, "ps-"),
		s == "ur-IN", strings.HasPrefix(s, "ur-IN-"),
		s == "uz-Arab", strings.HasPrefix(s, "uz-Arab-"):
		return numberingSystemArabext
	case s == "as", strings.HasPrefix(s, "as-"),
		s == "bn", strings.HasPrefix(s, "bn-"),
		s == "mni", strings.HasPrefix(s, "mni-"):
		return numberingSystemBeng
	case s == "ccp", strings.HasPrefix(s, "ccp-"):
		return numberingSystemCakm
	case s == "bgc", strings.HasPrefix(s, "bgc-"),
		s == "bho", strings.HasPrefix(s, "bho-"),
		s == "mr", strings.HasPrefix(s, "mr-"),
		s == "ne", strings.HasPrefix(s, "ne-"),
		s == "raj", strings.HasPrefix(s, "raj-"),
		s == "sa", strings.HasPrefix(s, "sa-"),
		s == "sat-Deva", strings.HasPrefix(s, "sat-Deva-"):
		return numberingSystemDeva
	case s == "hnj", strings.HasPrefix(s, "hnj-"):
		return numberingSystemHmnp
	case s == "ar-AE", strings.HasPrefix(s, "ar-AE-"),
		s == "ar-DZ", strings.HasPrefix(s, "ar-DZ-"),
		s == "ar-EH", strings.HasPrefix(s, "ar-EH-"),
		s == "ar-LY", strings.HasPrefix(s, "ar-LY-"),
		s == "ar-MA", strings.HasPrefix(s, "ar-MA-"),
		s == "ar-TN", strings.HasPrefix(s, "ar-TN-"):
		return numberingSystemLatn
	case s == "mni-Mtei", strings.HasPrefix(s, "mni-Mtei-"):
		return numberingSystemMtei
	case s == "my", strings.HasPrefix(s, "my-"):
		return numberingSystemMymr
	case s == "nqo", strings.HasPrefix(s, "nqo-"):
		return numberingSystemNkoo
	case s == "sat", strings.HasPrefix(s, "sat-"):
		return numberingSystemOlck
	case s == "dz", strings.HasPrefix(s, "dz-"):
		return numberingSystemTibt
	}
}

func defaultCalendar(locale language.Tag) string {
	switch v, _ := locale.Region(); v.String() {
	default:
		return "gregorian"
	case "AF", "IR":
		return "persian"
	case "SA":
		return "islamic-umalqura"
	case "TH":
		return "buddhist"
	}
}

func fmtYearBuddhist(locale language.Tag) func(string) string {
	lang, _ := locale.Base()

	switch lang.String() {
	default:
		return func(y string) string { return "AP " + y }
	case "be":
		return func(y string) string { return "G" + " " + y }
	case "yue":
		return func(y string) string { return "G" + y + "年" }
	case "ja":
		return func(y string) string { return "GGGG" + y + "年" }
	case "hi":
		return func(y string) string { return y + " " + "G" }
	}
}

func fmtMonthBuddhist(locale language.Tag, digits digits) func(month int, format string) string {
	lang, _ := locale.Base()

	fmt := func(m int, f string) string {
		if f == "01" && m <= 9 {
			return digits.Sprint("0" + strconv.Itoa(m))
		}

		return digits.Sprint(strconv.Itoa(m))
	}

	switch lang.String() {
	default:
		return fmt
	case "vi":
		return func(m int, f string) string { return "tháng " + fmt(m, f) }
	case "zh":
		return func(m int, f string) string { return fmt(m, f) + "月" }
	}
}

func fmtDayBuddhist(locale language.Tag, digits digits) func(day int, format string) string {
	lang, _ := locale.Base()

	fmt := func(d int, f string) string {
		if f == "02" && d <= 9 {
			return digits.Sprint("0" + strconv.Itoa(d))
		}

		return digits.Sprint(strconv.Itoa(d))
	}

	switch lang.String() {
	default:
		return fmt
	case "vi":
		return func(d int, f string) string { return "Ngày " + fmt(d, "02") }
	}
}

func fmtYearGregorian(locale language.Tag) func(string) string {
	lang, _ := locale.Base()

	switch lang.String() {
	default:
		return func(y string) string { return y }
	case "lv":
		return func(y string) string { return y + ". g." }
	case "bs", "hr", "hu", "sr":
		return func(y string) string { return y + "." }
	case "bg":
		return func(y string) string { return y + " г." }
	case "ja", "yue", "zh":
		return func(y string) string { return y + "年" }
	case "ko":
		return func(y string) string { return y + "년" }
	}
}

func fmtMonthGregorian(locale language.Tag, digits digits) func(month int, format string) string {
	lang, _ := locale.Base()

	fmt := func(m int, f string) string {
		if f == "01" && m <= 9 {
			return digits.Sprint("0" + strconv.Itoa(m))
		}

		return digits.Sprint(strconv.Itoa(m))
	}

	switch lang.String() {
	default:
		return fmt
	case "br", "lt":
		return func(m int, f string) string { return fmt(m, "01") }
	case "root", "aa", "ab", "af", "agq", "ak", "am", "an", "ann", "apc", "ar", "arn", "as", "asa", "ast", "az", "ba", "bal", "bas", "be", "bem", "bew", "bez", "bg", "bgc", "bgn", "bho", "blo", "blt", "bm", "bn", "bo", "brx", "bs", "bss", "byn", "ca", "cad", "cch", "ccp", "ce", "ceb", "cgg", "cho", "chr", "cic", "ckb", "co", "cs", "csw", "cu", "cv", "cy", "da", "dav", "de", "dje", "doi", "dsb", "dua", "dv", "dyo", "dz", "ebu", "ee", "el", "en", "eo", "es", "et", "eu", "ewo", "fa", "ff", "fi", "fil", "fo", "fr", "fur", "fy", "ga", "gaa", "gd", "gez", "gl", "gn", "gsw", "gu", "guz", "gv", "ha", "haw", "he", "hi", "hnj", "hsb", "hu", "hy", "ia", "id", "ie", "ig", "ii", "io", "is", "it", "iu", "jbo", "jgo", "jmc", "jv", "ka", "kab", "kaj", "kam", "kcg", "kde", "kea", "ken", "kgp", "khq", "ki", "kk", "kkj", "kl", "kln", "km", "kn", "kok", "kpe", "ks", "ksb", "ksf", "ksh", "ku", "kw", "kxv", "ky", "la", "lag", "lb", "lg", "lij", "lkt", "lmo", "ln", "lo", "lrc", "lu", "luo", "luy", "lv", "mai", "mas", "mdf", "mer", "mfe", "mg", "mgh", "mgo", "mi", "mic", "mk", "ml", "mn", "mni", "moh", "mr", "ms", "mt", "mua", "mus", "my", "myv", "mzn", "naq", "nd", "nds", "ne", "nl", "nmg", "nnh", "nqo", "nr", "nso", "nus", "nv", "ny", "nyn", "oc", "om", "or", "os", "osa", "pa", "pap", "pcm", "pis", "pl", "ps", "pt", "qu", "quc", "raj", "rhg", "rif", "rm", "rn", "ro", "rof", "ru", "rw", "rwk", "sa", "sah", "saq", "sat", "sbp", "sc", "scn", "sd", "sdh", "se", "seh", "ses", "sg", "shi", "shn", "si", "sid", "skr", "sl", "sma", "smj", "smn", "sms", "sn", "so", "sq", "sr", "ss", "ssy", "st", "su", "sv", "sw", "syr", "szl", "ta", "te", "teo", "tg", "th", "ti", "tig", "tk", "tn", "to", "tok", "tpi", "tr", "trv", "trw", "ts", "tt", "twq", "tyv", "tzm", "ug", "uk", "ur", "uz", "vai", "ve", "vec", "vi", "vmw", "vo", "vun", "wa", "wae", "wal", "wbp", "wo", "xh", "xnr", "xog", "yav", "yi", "yo", "yrl", "za", "zgh", "zu":
		return func(m int, f string) string { return fmt(m, f) }
	case "hr", "nb", "nn", "no", "sk":
		return func(m int, f string) string { return fmt(m, f) + "." }
	case "ja", "yue", "zh":
		return func(m int, f string) string { return fmt(m, f) + "月" }
	case "ko":
		return func(m int, f string) string { return fmt(m, f) + "월" }
	}
}

func fmtDayGregorian(locale language.Tag, digits digits) func(day int, format string) string {
	lang, _ := locale.Base()

	fmt := func(d int, f string) string {
		if f == "02" && d <= 9 {
			return digits.Sprint("0" + strconv.Itoa(d))
		}

		return digits.Sprint(strconv.Itoa(d))
	}

	switch lang.String() {
	default:
		return fmt
	case "lt":
		return func(d int, f string) string { return fmt(d, "02") }
	case "bs", "cs", "da", "dsb", "fo", "hr", "hsb", "nb", "nn", "no", "sk", "sl":
		return func(d int, f string) string { return fmt(d, f) + "." }
	case "ja", "yue", "zh":
		return func(d int, f string) string { return fmt(d, f) + "日" }
	case "ko":
		return func(d int, f string) string { return fmt(d, f) + "일" }
	}
}

func fmtYearPersian(locale language.Tag) func(string) string {
	lang, _ := locale.Base()

	switch lang.String() {
	default:
		return func(y string) string { return "AP " + y }
	case "fa":
		return func(y string) string { return y }
	}
}

func fmtMonthPersian(_ language.Tag, digits digits) func(month int, format string) string {
	fmt := func(m int, f string) string {
		if f == "01" && m <= 9 {
			return digits.Sprint("0" + strconv.Itoa(m))
		}

		return digits.Sprint(strconv.Itoa(m))
	}

	return fmt
}

func fmtDayPersian(_ language.Tag, digits digits) func(day int, format string) string {
	fmt := func(d int, f string) string {
		if f == "02" && d <= 9 {
			return digits.Sprint("0" + strconv.Itoa(d))
		}

		return digits.Sprint(strconv.Itoa(d))
	}

	return fmt
}

type gregorianDateTimeFormat struct {
	time     time.Time
	fmtYear  func(format string) string
	fmtMonth func(month int, format string) string
	fmtDay   func(day int, format string) string
	digits   digits
}

func (f *gregorianDateTimeFormat) SetTime(v time.Time) {
	f.time = v
}

func (f *gregorianDateTimeFormat) Year(format string) string {
	return f.fmtYear(f.digits.Sprint(f.time.Format(format)))
}

func (f *gregorianDateTimeFormat) Month(format string) string {
	return f.fmtMonth(int(f.time.Month()), format)
}

func (f *gregorianDateTimeFormat) Day(format string) string {
	return f.fmtDay(f.time.Day(), format)
}

type persianDateTimeFormat struct {
	time     ptime.Time
	fmtYear  func(format string) string
	fmtMonth func(month int, format string) string
	fmtDay   func(day int, format string) string
	digits   digits
}

func (f *persianDateTimeFormat) SetTime(v time.Time) {
	f.time = ptime.New(v)
}

// Year returns formatted year (only "06" and "2006" is supported).
func (f *persianDateTimeFormat) Year(format string) string {
	year := strconv.Itoa(f.time.Year())

	// ptime.Time.Format is very slow. Make it fast!
	if format == "06" {
		switch len(year) {
		default:
			year = year[len(year)-2:]
		case 1:
			year = "0" + year
		case 0, 2: // noop, isSliceInBounds()
		}
	}

	return f.fmtYear(f.digits.Sprint(year))
}

func (f *persianDateTimeFormat) Month(format string) string {
	return f.fmtMonth(int(f.time.Month()), format)
}

func (f *persianDateTimeFormat) Day(format string) string {
	return f.fmtDay(f.time.Day(), format)
}

type buddhistDateTimeFormat struct {
	time     time.Time
	fmtYear  func(format string) string
	fmtMonth func(month int, format string) string
	fmtDay   func(day int, format string) string
	digits   digits
}

func (f *buddhistDateTimeFormat) SetTime(v time.Time) {
	f.time = v.AddDate(543, 0, 0)
}

func (f *buddhistDateTimeFormat) Year(format string) string {
	year := strconv.Itoa(f.time.Year())

	// ptime.Time.Format is very slow. Make it fast!
	if format == "06" {
		switch len(year) {
		default:
			year = year[len(year)-2:]
		case 1:
			year = "0" + year
		case 0, 2: // noop, isSliceInBounds()
		}
	}

	return f.fmtYear(f.digits.Sprint(year))
}

func (f *buddhistDateTimeFormat) Month(format string) string {
	return f.fmtMonth(int(f.time.Month()), format)
}

func (f *buddhistDateTimeFormat) Day(format string) string {
	return f.fmtDay(f.time.Day(), format)
}
