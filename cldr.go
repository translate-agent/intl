package intl

// Code generated by "earthly +generate". DO NOT EDIT.

import (
	"strconv"
	"strings"
	"time"

	ptime "github.com/yaa110/go-persian-calendar"
	"golang.org/x/text/language"
)

type numberingSystem int

const (
	numberingSystemLatn numberingSystem = iota
	numberingSystemAdlm
	numberingSystemArab
	numberingSystemArabext
	numberingSystemBeng
	numberingSystemCakm
	numberingSystemDeva
	numberingSystemHmnp
	numberingSystemMtei
	numberingSystemMymr
	numberingSystemNkoo
	numberingSystemOlck
	numberingSystemTibt
	numberingSystemLast
)

var numberingSystems = []digits{
	numberingSystemAdlm:    {'ğ¥', 'ğ¥‘', 'ğ¥’', 'ğ¥“', 'ğ¥”', 'ğ¥•', 'ğ¥–', 'ğ¥—', 'ğ¥˜', 'ğ¥™'},
	numberingSystemArab:    {'Ù ', 'Ù¡', 'Ù¢', 'Ù£', 'Ù¤', 'Ù¥', 'Ù¦', 'Ù§', 'Ù¨', 'Ù©'},
	numberingSystemArabext: {'Û°', 'Û±', 'Û²', 'Û³', 'Û´', 'Ûµ', 'Û¶', 'Û·', 'Û¸', 'Û¹'},
	numberingSystemBeng:    {'à§¦', 'à§§', 'à§¨', 'à§©', 'à§ª', 'à§«', 'à§¬', 'à§­', 'à§®', 'à§¯'},
	numberingSystemCakm:    {'ğ‘„¶', 'ğ‘„·', 'ğ‘„¸', 'ğ‘„¹', 'ğ‘„º', 'ğ‘„»', 'ğ‘„¼', 'ğ‘„½', 'ğ‘„¾', 'ğ‘„¿'},
	numberingSystemDeva:    {'à¥¦', 'à¥§', 'à¥¨', 'à¥©', 'à¥ª', 'à¥«', 'à¥¬', 'à¥­', 'à¥®', 'à¥¯'},
	numberingSystemHmnp:    {'ğ…€', 'ğ…', 'ğ…‚', 'ğ…ƒ', 'ğ…„', 'ğ……', 'ğ…†', 'ğ…‡', 'ğ…ˆ', 'ğ…‰'},
	numberingSystemMtei:    {'ê¯°', 'ê¯±', 'ê¯²', 'ê¯³', 'ê¯´', 'ê¯µ', 'ê¯¶', 'ê¯·', 'ê¯¸', 'ê¯¹'},
	numberingSystemMymr:    {'á€', 'á', 'á‚', 'áƒ', 'á„', 'á…', 'á†', 'á‡', 'áˆ', 'á‰'},
	numberingSystemNkoo:    {'ß€', 'ß', 'ß‚', 'ßƒ', 'ß„', 'ß…', 'ß†', 'ß‡', 'ßˆ', 'ß‰'},
	numberingSystemOlck:    {'á±', 'á±‘', 'á±’', 'á±“', 'á±”', 'á±•', 'á±–', 'á±—', 'á±˜', 'á±™'},
	numberingSystemTibt:    {'à¼ ', 'à¼¡', 'à¼¢', 'à¼£', 'à¼¤', 'à¼¥', 'à¼¦', 'à¼§', 'à¼¨', 'à¼©'},
}

func defaultNumberingSystem(locale language.Tag) numberingSystem {
	s := locale.String()

	switch {
	default:
		return numberingSystemLatn
	case s == "ff-Adlm", strings.HasPrefix(s, "ff-Adlm-"):
		return numberingSystemAdlm
	case s == "ar", strings.HasPrefix(s, "ar-"),
		s == "ar-BH", strings.HasPrefix(s, "ar-BH-"),
		s == "ar-DJ", strings.HasPrefix(s, "ar-DJ-"),
		s == "ar-EG", strings.HasPrefix(s, "ar-EG-"),
		s == "ar-ER", strings.HasPrefix(s, "ar-ER-"),
		s == "ar-IL", strings.HasPrefix(s, "ar-IL-"),
		s == "ar-IQ", strings.HasPrefix(s, "ar-IQ-"),
		s == "ar-JO", strings.HasPrefix(s, "ar-JO-"),
		s == "ar-KM", strings.HasPrefix(s, "ar-KM-"),
		s == "ar-KW", strings.HasPrefix(s, "ar-KW-"),
		s == "ar-LB", strings.HasPrefix(s, "ar-LB-"),
		s == "ar-MR", strings.HasPrefix(s, "ar-MR-"),
		s == "ar-OM", strings.HasPrefix(s, "ar-OM-"),
		s == "ar-PS", strings.HasPrefix(s, "ar-PS-"),
		s == "ar-QA", strings.HasPrefix(s, "ar-QA-"),
		s == "ar-SA", strings.HasPrefix(s, "ar-SA-"),
		s == "ar-SD", strings.HasPrefix(s, "ar-SD-"),
		s == "ar-SO", strings.HasPrefix(s, "ar-SO-"),
		s == "ar-SS", strings.HasPrefix(s, "ar-SS-"),
		s == "ar-SY", strings.HasPrefix(s, "ar-SY-"),
		s == "ar-TD", strings.HasPrefix(s, "ar-TD-"),
		s == "ar-YE", strings.HasPrefix(s, "ar-YE-"),
		s == "ckb", strings.HasPrefix(s, "ckb-"),
		s == "sd", strings.HasPrefix(s, "sd-"),
		s == "sdh", strings.HasPrefix(s, "sdh-"):
		return numberingSystemArab
	case s == "az-Arab", strings.HasPrefix(s, "az-Arab-"),
		s == "bgn", strings.HasPrefix(s, "bgn-"),
		s == "fa", strings.HasPrefix(s, "fa-"),
		s == "ks", strings.HasPrefix(s, "ks-"),
		s == "lrc", strings.HasPrefix(s, "lrc-"),
		s == "mzn", strings.HasPrefix(s, "mzn-"),
		s == "pa-Arab", strings.HasPrefix(s, "pa-Arab-"),
		s == "ps", strings.HasPrefix(s, "ps-"),
		s == "ur-IN", strings.HasPrefix(s, "ur-IN-"),
		s == "uz-Arab", strings.HasPrefix(s, "uz-Arab-"):
		return numberingSystemArabext
	case s == "as", strings.HasPrefix(s, "as-"),
		s == "bn", strings.HasPrefix(s, "bn-"),
		s == "mni", strings.HasPrefix(s, "mni-"):
		return numberingSystemBeng
	case s == "ccp", strings.HasPrefix(s, "ccp-"):
		return numberingSystemCakm
	case s == "bgc", strings.HasPrefix(s, "bgc-"),
		s == "bho", strings.HasPrefix(s, "bho-"),
		s == "mr", strings.HasPrefix(s, "mr-"),
		s == "ne", strings.HasPrefix(s, "ne-"),
		s == "raj", strings.HasPrefix(s, "raj-"),
		s == "sa", strings.HasPrefix(s, "sa-"),
		s == "sat-Deva", strings.HasPrefix(s, "sat-Deva-"):
		return numberingSystemDeva
	case s == "hnj", strings.HasPrefix(s, "hnj-"):
		return numberingSystemHmnp
	case s == "ar-AE", strings.HasPrefix(s, "ar-AE-"),
		s == "ar-DZ", strings.HasPrefix(s, "ar-DZ-"),
		s == "ar-EH", strings.HasPrefix(s, "ar-EH-"),
		s == "ar-LY", strings.HasPrefix(s, "ar-LY-"),
		s == "ar-MA", strings.HasPrefix(s, "ar-MA-"),
		s == "ar-TN", strings.HasPrefix(s, "ar-TN-"):
		return numberingSystemLatn
	case s == "mni-Mtei", strings.HasPrefix(s, "mni-Mtei-"):
		return numberingSystemMtei
	case s == "my", strings.HasPrefix(s, "my-"):
		return numberingSystemMymr
	case s == "nqo", strings.HasPrefix(s, "nqo-"):
		return numberingSystemNkoo
	case s == "sat", strings.HasPrefix(s, "sat-"):
		return numberingSystemOlck
	case s == "dz", strings.HasPrefix(s, "dz-"):
		return numberingSystemTibt
	}
}

func defaultCalendar(locale language.Tag) string {
	switch v, _ := locale.Region(); v.String() {
	default:
		return "gregorian"
	case "AF", "IR":
		return "persian"
	case "SA":
		return "islamic-umalqura"
	case "TH":
		return "buddhist"
	}
}

func fmtYearBuddhist(locale language.Tag) func(string) string {
	lang, _ := locale.Base()

	switch lang.String() {
	default:
		return func(y string) string { return "AP " + y }
	case "be":
		return func(y string) string { return "G" + " " + y }
	case "yue":
		return func(y string) string { return "G" + y + "å¹´" }
	case "ja":
		return func(y string) string { return "GGGG" + y + "å¹´" }
	case "hi":
		return func(y string) string { return y + " " + "G" }
	}
}

func fmtDayBuddhist(locale language.Tag, digits digits) func(day int, format string) string {
	lang, _ := locale.Base()

	fmt := func(d int, f string) string {
		if f == "02" && d <= 9 {
			return digits.Sprint("0" + strconv.Itoa(d))
		}

		return digits.Sprint(strconv.Itoa(d))
	}

	switch lang.String() {
	default:
		return fmt
	case "vi":
		return func(d int, f string) string { return "'" + fmt(d, f) + fmt(d, f) + "Ã " + fmt(d, f) + " dd" }
	}
}

func fmtYearGregorian(locale language.Tag) func(string) string {
	lang, _ := locale.Base()

	switch lang.String() {
	default:
		return func(y string) string { return y }
	case "lv":
		return func(y string) string { return y + ". g." }
	case "bs", "hr", "hu", "sr":
		return func(y string) string { return y + "." }
	case "bg":
		return func(y string) string { return y + "â€¯Ğ³." }
	case "ja", "yue", "zh":
		return func(y string) string { return y + "å¹´" }
	case "ko":
		return func(y string) string { return y + "ë…„" }
	}
}

func fmtDayGregorian(locale language.Tag, digits digits) func(day int, format string) string {
	lang, _ := locale.Base()

	fmt := func(d int, f string) string {
		if f == "02" && d <= 9 {
			return digits.Sprint("0" + strconv.Itoa(d))
		}

		return digits.Sprint(strconv.Itoa(d))
	}

	switch lang.String() {
	default:
		return fmt
	case "lt":
		return func(d int, f string) string { return fmt(d, "02") }
	case "bs", "cs", "da", "dsb", "fo", "hr", "hsb", "nb", "nn", "no", "sk", "sl":
		return func(d int, f string) string { return fmt(d, f) + "." }
	case "ja", "yue", "zh":
		return func(d int, f string) string { return fmt(d, f) + "æ—¥" }
	case "ko":
		return func(d int, f string) string { return fmt(d, f) + "ì¼" }
	}
}

func fmtYearPersian(locale language.Tag) func(string) string {
	lang, _ := locale.Base()

	switch lang.String() {
	default:
		return func(y string) string { return "AP " + y }
	case "fa":
		return func(y string) string { return y }
	}
}

func fmtDayPersian(_ language.Tag, digits digits) func(day int, format string) string {
	fmt := func(d int, f string) string {
		if f == "02" && d <= 9 {
			return digits.Sprint("0" + strconv.Itoa(d))
		}

		return digits.Sprint(strconv.Itoa(d))
	}

	return fmt
}

type gregorianDateTimeFormat struct {
	time    time.Time
	fmtYear func(format string) string
	fmtDay  func(day int, format string) string
	digits  digits
}

func (f *gregorianDateTimeFormat) SetTime(v time.Time) {
	f.time = v
}

func (f *gregorianDateTimeFormat) Year(format string) string {
	return f.fmtYear(f.digits.Sprint(f.time.Format(format)))
}

func (f *gregorianDateTimeFormat) Day(format string) string {
	return f.fmtDay(f.time.Day(), format)
}

type persianDateTimeFormat struct {
	time    ptime.Time
	fmtYear func(format string) string
	fmtDay  func(day int, format string) string
	digits  digits
}

func (f *persianDateTimeFormat) SetTime(v time.Time) {
	f.time = ptime.New(v)
}

// Year returns formatted year (only "06" and "2006" is supported).
func (f *persianDateTimeFormat) Year(format string) string {
	year := strconv.Itoa(f.time.Year())

	// ptime.Time.Format is very slow. Make it fast!
	if format == "06" {
		switch len(year) {
		default:
			year = year[len(year)-2:]
		case 1:
			year = "0" + year
		case 0, 2: // noop, isSliceInBounds()
		}
	}

	return f.fmtYear(f.digits.Sprint(year))
}

func (f *persianDateTimeFormat) Day(format string) string {
	return f.fmtDay(f.time.Day(), format)
}

type buddhistDateTimeFormat struct {
	time    time.Time
	fmtYear func(format string) string
	fmtDay  func(day int, format string) string
	digits  digits
}

func (f *buddhistDateTimeFormat) SetTime(v time.Time) {
	f.time = v.AddDate(543, 0, 0)
}

func (f *buddhistDateTimeFormat) Year(format string) string {
	year := strconv.Itoa(f.time.Year())

	// ptime.Time.Format is very slow. Make it fast!
	if format == "06" {
		switch len(year) {
		default:
			year = year[len(year)-2:]
		case 1:
			year = "0" + year
		case 0, 2: // noop, isSliceInBounds()
		}
	}

	return f.fmtYear(f.digits.Sprint(year))
}

func (f *buddhistDateTimeFormat) Day(format string) string {
	return f.fmtDay(f.time.Day(), format)
}
